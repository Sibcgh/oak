// This file is @generated by prost-build.
/// Request message containing the input data and Wasm module to execute
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteRequest {
    /// Binary data to operate on
    #[prost(bytes = "vec", tag = "1")]
    pub input_data: ::prost::alloc::vec::Vec<u8>,
    /// Wasm module bytecode to execute
    #[prost(bytes = "vec", tag = "2")]
    pub wasm_module: ::prost::alloc::vec::Vec<u8>,
}
/// Manifest containing digests of all inputs and outputs for verification
/// TODO: b/448322106 - Consider using in-toto or SLSA instead of this protobuf.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionManifest {
    /// Digest of the input data
    #[prost(message, optional, tag = "1")]
    pub input_data_digest: ::core::option::Option<super::RawDigest>,
    /// Digest of the Wasm module
    #[prost(message, optional, tag = "2")]
    pub wasm_module_digest: ::core::option::Option<super::RawDigest>,
    /// Digest of the output data
    #[prost(message, optional, tag = "3")]
    pub output_data_digest: ::core::option::Option<super::RawDigest>,
}
/// Response message containing both the execution manifest and raw output
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteResponse {
    /// Manifest with digests for verification
    /// TODO: b/448322106 - Change this to serialized bytes + signature (probably a
    /// map of Oak Assertions).
    #[prost(message, optional, tag = "1")]
    pub manifest: ::core::option::Option<ExecutionManifest>,
    /// Raw output bytes from Wasm execution
    #[prost(bytes = "vec", tag = "2")]
    pub output_data: ::prost::alloc::vec::Vec<u8>,
}
